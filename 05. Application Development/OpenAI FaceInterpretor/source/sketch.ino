#include <SPI.h>
#include "Arduino_RouterBridge.h"

// Pin Definitionen
const int PIN_CS  = 10; // Chip Select (Active Low)
const int PIN_RES = 9;  // Reset
const int PIN_DC  = 8;  // Data/Command

// ---------------- ST7789 Commands ----------------
#define SWRESET   0x01
#define SLPOUT    0x11
#define COLMOD    0x3A
#define MADCTL    0x36
#define CASET     0x2A
#define RASET     0x2B
#define RAMWR     0x2C
#define DISPON    0x29

// ---------------- Display ----------------
#define TFT_WIDTH  280
#define TFT_HEIGHT 250

// ---------------- Colors (RGB565) ----------------
#define BLACK 0x0000
#define WHITE 0xFFFF

// ---------------- Offset ------------------------
#define X_OFFSET 20
#define Y_OFFSET -25 

// ---------------- Scaling ------------------------
#define SCALE 2

// ---------------- Wrapping ------------------------
#define SCALE 2
#define FONT_WIDTH 5
#define FONT_HEIGHT 7
#define FONT_SPACING 1 // Abstand zwischen Zeichen


// ---------------- 5x7 Font (ASCII 32–127) ----------------
#include <avr/pgmspace.h>

const uint8_t font5x7[][5] PROGMEM = {
  {0x00,0x00,0x00,0x00,0x00}, // 32 ' '
  {0x00,0x00,0x5F,0x00,0x00}, // 33 '!'
  {0x00,0x07,0x00,0x07,0x00}, // 34 '"'
  {0x14,0x7F,0x14,0x7F,0x14}, // 35 '#'
  {0x24,0x2A,0x7F,0x2A,0x12}, // 36 '$'
  {0x23,0x13,0x08,0x64,0x62}, // 37 '%'
  {0x36,0x49,0x55,0x22,0x50}, // 38 '&'
  {0x00,0x05,0x03,0x00,0x00}, // 39 '''
  {0x00,0x1C,0x22,0x41,0x00}, // 40 '('
  {0x00,0x41,0x22,0x1C,0x00}, // 41 ')'
  {0x14,0x08,0x3E,0x08,0x14}, // 42 '*'
  {0x08,0x08,0x3E,0x08,0x08}, // 43 '+'
  {0x00,0x50,0x30,0x00,0x00}, // 44 ','
  {0x08,0x08,0x08,0x08,0x08}, // 45 '-'
  {0x00,0x60,0x60,0x00,0x00}, // 46 '.'
  {0x20,0x10,0x08,0x04,0x02}, // 47 '/'

  {0x3E,0x51,0x49,0x45,0x3E}, // 48 '0'
  {0x00,0x42,0x7F,0x40,0x00}, // 49 '1'
  {0x42,0x61,0x51,0x49,0x46}, // 50 '2'
  {0x21,0x41,0x45,0x4B,0x31}, // 51 '3'
  {0x18,0x14,0x12,0x7F,0x10}, // 52 '4'
  {0x27,0x45,0x45,0x45,0x39}, // 53 '5'
  {0x3C,0x4A,0x49,0x49,0x30}, // 54 '6'
  {0x01,0x71,0x09,0x05,0x03}, // 55 '7'
  {0x36,0x49,0x49,0x49,0x36}, // 56 '8'
  {0x06,0x49,0x49,0x29,0x1E}, // 57 '9'

  {0x00,0x36,0x36,0x00,0x00}, // 58 ':'
  {0x00,0x56,0x36,0x00,0x00}, // 59 ';'
  {0x08,0x14,0x22,0x41,0x00}, // 60 '<'
  {0x14,0x14,0x14,0x14,0x14}, // 61 '='
  {0x00,0x41,0x22,0x14,0x08}, // 62 '>'
  {0x02,0x01,0x51,0x09,0x06}, // 63 '?'
  {0x32,0x49,0x79,0x41,0x3E}, // 64 '@'

  {0x7E,0x11,0x11,0x11,0x7E}, // 65 'A'
  {0x7F,0x49,0x49,0x49,0x36}, // 66 'B'
  {0x3E,0x41,0x41,0x41,0x22}, // 67 'C'
  {0x7F,0x41,0x41,0x22,0x1C}, // 68 'D'
  {0x7F,0x49,0x49,0x49,0x41}, // 69 'E'
  {0x7F,0x09,0x09,0x09,0x01}, // 70 'F'
  {0x3E,0x41,0x49,0x49,0x7A}, // 71 'G'
  {0x7F,0x08,0x08,0x08,0x7F}, // 72 'H'
  {0x00,0x41,0x7F,0x41,0x00}, // 73 'I'
  {0x20,0x40,0x41,0x3F,0x01}, // 74 'J'
  {0x7F,0x08,0x14,0x22,0x41}, // 75 'K'
  {0x7F,0x40,0x40,0x40,0x40}, // 76 'L'
  {0x7F,0x02,0x04,0x02,0x7F}, // 77 'M'
  {0x7F,0x04,0x08,0x10,0x7F}, // 78 'N'
  {0x3E,0x41,0x41,0x41,0x3E}, // 79 'O'
  {0x7F,0x09,0x09,0x09,0x06}, // 80 'P'
  {0x3E,0x41,0x51,0x21,0x5E}, // 81 'Q'
  {0x7F,0x09,0x19,0x29,0x46}, // 82 'R'
  {0x46,0x49,0x49,0x49,0x31}, // 83 'S'
  {0x01,0x01,0x7F,0x01,0x01}, // 84 'T'
  {0x3F,0x40,0x40,0x40,0x3F}, // 85 'U'
  {0x1F,0x20,0x40,0x20,0x1F}, // 86 'V'
  {0x3F,0x40,0x38,0x40,0x3F}, // 87 'W'
  {0x63,0x14,0x08,0x14,0x63}, // 88 'X'
  {0x07,0x08,0x70,0x08,0x07}, // 89 'Y'
  {0x61,0x51,0x49,0x45,0x43}, // 90 'Z'

  {0x00,0x7F,0x41,0x41,0x00}, // 91 '['
  {0x02,0x04,0x08,0x10,0x20}, // 92 '\'
  {0x00,0x41,0x41,0x7F,0x00}, // 93 ']'
  {0x04,0x02,0x01,0x02,0x04}, // 94 '^'
  {0x40,0x40,0x40,0x40,0x40}, // 95 '_'
  {0x00,0x01,0x02,0x04,0x00}, // 96 '`'

  {0x20,0x54,0x54,0x54,0x78}, // 97 'a'
  {0x7F,0x48,0x44,0x44,0x38}, // 98 'b'
  {0x38,0x44,0x44,0x44,0x20}, // 99 'c'
  {0x38,0x44,0x44,0x48,0x7F}, // 100 'd'
  {0x38,0x54,0x54,0x54,0x18}, // 101 'e'
  {0x08,0x7E,0x09,0x01,0x02}, // 102 'f'
  {0x08,0x14,0x54,0x54,0x3C}, // 103 'g'
  {0x7F,0x08,0x04,0x04,0x78}, // 104 'h'
  {0x00,0x44,0x7D,0x40,0x00}, // 105 'i'
  {0x20,0x40,0x44,0x3D,0x00}, // 106 'j'
  {0x7F,0x10,0x28,0x44,0x00}, // 107 'k'
  {0x00,0x41,0x7F,0x40,0x00}, // 108 'l'
  {0x7C,0x04,0x18,0x04,0x78}, // 109 'm'
  {0x7C,0x08,0x04,0x04,0x78}, // 110 'n'
  {0x38,0x44,0x44,0x44,0x38}, // 111 'o'
  {0x7C,0x14,0x14,0x14,0x08}, // 112 'p'
  {0x08,0x14,0x14,0x18,0x7C}, // 113 'q'
  {0x7C,0x08,0x04,0x04,0x08}, // 114 'r'
  {0x48,0x54,0x54,0x54,0x20}, // 115 's'
  {0x04,0x3F,0x44,0x40,0x20}, // 116 't'
  {0x3C,0x40,0x40,0x20,0x7C}, // 117 'u'
  {0x1C,0x20,0x40,0x20,0x1C}, // 118 'v'
  {0x3C,0x40,0x30,0x40,0x3C}, // 119 'w'
  {0x44,0x28,0x10,0x28,0x44}, // 120 'x'
  {0x0C,0x50,0x50,0x50,0x3C}, // 121 'y'
  {0x44,0x64,0x54,0x4C,0x44}, // 122 'z'

  {0x00,0x08,0x36,0x41,0x00}, // 123 '{'
  {0x00,0x00,0x7F,0x00,0x00}, // 124 '|'
  {0x00,0x41,0x36,0x08,0x00}, // 125 '}'
  {0x08,0x08,0x2A,0x1C,0x08}, // 126 '~'
  {0x00,0x00,0x00,0x00,0x00}  // 127 DEL
};

// ---------------- Low-Level SPI ----------------
void sendCommand(uint8_t cmd) {
  digitalWrite(PIN_DC, LOW);
  digitalWrite(PIN_CS, LOW);
  SPI.transfer(cmd);
  digitalWrite(PIN_CS, HIGH);
}

void sendData(uint8_t data) {
  digitalWrite(PIN_DC, HIGH);
  digitalWrite(PIN_CS, LOW);
  SPI.transfer(data);
  digitalWrite(PIN_CS, HIGH);
}

// ---------------- Address Window ----------------
void setWindow(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1) {
  x0 += X_OFFSET;
  x1 += X_OFFSET;
  y0 += Y_OFFSET;
  y1 += Y_OFFSET;

  sendCommand(CASET);
  sendData(x0 >> 8); sendData(x0 & 0xFF);
  sendData(x1 >> 8); sendData(x1 & 0xFF);

  sendCommand(RASET);
  sendData(y0 >> 8); sendData(y0 & 0xFF);
  sendData(y1 >> 8); sendData(y1 & 0xFF);

  sendCommand(RAMWR);
}


// ---------------- Drawing ----------------
void drawPixel(uint16_t x, uint16_t y, uint16_t color) {
  if (x >= TFT_WIDTH || y >= TFT_HEIGHT) return;
  setWindow(x, y, x, y);
  digitalWrite(PIN_DC, HIGH);
  digitalWrite(PIN_CS, LOW);
  SPI.transfer(color >> 8);
  SPI.transfer(color & 0xFF);
  digitalWrite(PIN_CS, HIGH);
}

void fillScreen(uint16_t color) {
  setWindow(0, 0, TFT_WIDTH - 1, TFT_HEIGHT - 1);
  digitalWrite(PIN_DC, HIGH);
  digitalWrite(PIN_CS, LOW);
  for (uint32_t i = 0; i < (uint32_t)TFT_WIDTH * TFT_HEIGHT; i++) {
    SPI.transfer(color >> 8);
    SPI.transfer(color & 0xFF);
  }
  digitalWrite(PIN_CS, HIGH);
}

void drawCharScaled(
  uint16_t x,
  uint16_t y,
  char c,
  uint16_t color,
  uint8_t scale
) {
  if (c < 32 || c > 127) return;

  const uint8_t *bitmap = font5x7[c - 32];

  for (uint8_t col = 0; col < 5; col++) {
    uint8_t line = pgm_read_byte(&bitmap[col]);

    for (uint8_t row = 0; row < 7; row++) {
      if (line & 0x01) {
        // skaling Pixel (Block)
        for (uint8_t dx = 0; dx < scale; dx++) {
          for (uint8_t dy = 0; dy < scale; dy++) {
            drawPixel(
              x + col * scale + dx,
              y + row * scale + dy,
              color
            );
          }
        }
      }
      line >>= 1;
    }
  }
}


void drawTextScaled(
  uint16_t x,
  uint16_t y,
  const char *text,
  uint16_t color,
  uint8_t scale
) {
  uint16_t cursorX = x;

  while (*text) {
    drawCharScaled(cursorX, y, *text++, color, scale);
    cursorX += (5 + 1) * scale; // char width + distance
  }
}

void drawTextWrapped(
  uint16_t x,
  uint16_t y,
  const char *text,
  uint16_t color,
  uint8_t scale
) {
  uint16_t cursorX = x;
  uint16_t cursorY = y;

  const uint16_t charWidth  = (FONT_WIDTH + FONT_SPACING) * scale;
  const uint16_t charHeight = FONT_HEIGHT * scale;

  while (*text) {
    char c = *text++;

    // expicit carrage return
    if (c == '\n') {
      cursorX = x;
      cursorY += charHeight+5;
      continue;
    }

    // automatical carriage return
    if (cursorX + charWidth > TFT_WIDTH) {
      cursorX = x;
      cursorY += charHeight+5;
    }

    // stop, if screen is full
    if (cursorY + charHeight > TFT_HEIGHT) {
      break;
    }

    drawCharScaled(cursorX, cursorY, c, color, scale);
    cursorX += charWidth;
  }
}

// Diese Funktion wird von Python aus aufgerufen
void printFromPython(String text) {
    // Bildschirm löschen
    fillScreen(BLACK); 
    
    // c_str() wandelt das String-Objekt in den benötigten char-Pointer um
    drawTextWrapped(20, 40, text.c_str(), WHITE, 2);
}


// ---------------- Setup ----------------
void setup() {
  // Steuerleitungen als Ausgang konfigurieren
  pinMode(PIN_CS, OUTPUT);
  pinMode(PIN_RES, OUTPUT);
  pinMode(PIN_DC, OUTPUT);

  SPI.begin();
  // 1 MHz für gute Sichtbarkeit am Scope
  SPI.beginTransaction(SPISettings(10000000, MSBFIRST, SPI_MODE0));

  Serial.begin(115200);
  Serial.println("Display-Signal-Test gestartet...");

  // Reset
  digitalWrite(PIN_RES, LOW);
  delay(50);
  digitalWrite(PIN_RES, HIGH);
  delay(150);

  sendCommand(SWRESET);
  delay(150);

  sendCommand(SLPOUT);
  delay(150);

  sendCommand(COLMOD);
  sendData(0x55); // RGB565

  sendCommand(MADCTL);
  sendData(0xA0);

  sendCommand(DISPON);
  delay(100);

  fillScreen(BLACK);

  // Registrierung der Bridge-Funktion
  Bridge.begin();
  Bridge.provide("display_print", printFromPython);

}


void loop() {
  
}

